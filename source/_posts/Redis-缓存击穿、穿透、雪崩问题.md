---
title: Redis 缓存击穿、穿透、雪崩问题
catalog: true
subtitle: redis 缓存击穿等简单分析
header-img: 'http://pvpmnqrh8.bkt.clouddn.com/tag-bg.png'
tags:
  - redis
categories:
  - web
abbrlink: 7b82129d
date: 2019-08-06 10:55:39
---

## 正常缓存工作流程
当用户请求某资源时，首先查看是否命中缓存。若命中，直接返回缓存数据。若未命中，则去数据存储中查询当数据返回，并放入缓存中。以便下回再次请求该资源，可命中缓存。降低底层存储压力。

## 缓存穿透
- 场景描述
     当用户请求某个一定不存在的资源时，该请求一定无法命中缓存，因此每次请求都会打到底层存储。同时底层存储中也不存在该资源，无法更新缓存。这就导致了这个不存在的资源请求，每一次都会到底层存储去查询，缓存失效。如果有大量的此类请求，可能会导致DB挂掉，服务中断。

- 解决方案
    1.当用户请求了不存在的数据时，我们可以将从底层存储中查询到的空值或自定义的无效代码存入redis中，但是需要设置一个较短的失效时间（可是分钟级别的，不宜太长或太短）。
    2.采用布隆过滤器,将所有可能存在的数据哈希到一个足够大的bitmap中,一个一定不存在的数据会被这个bitmap拦截掉,从而避免了对底层存储系统的查询压力.

## 缓存击穿
- 场景描述
    根据正常的缓存工作流程，首先查询redis缓存中是否存在，在未命中缓存时去查询数据库中的数据，并将数据放入redis中。
    但是如果存在某个高并发的key，该key在某个时间过期了。同时该时间点，有大量关于该key的请求进入系统。发现在redis中不存在该数据，所有的请求都会到DB中去访问。瞬时的请求可能将DB打死，造成服务中断。

- 解决方案
    1.设置key 永不过期（不建议）
    2.添加互斥锁，保证只有一条请求去查询数据库，并更新缓存。（只能保证单机）
    3.使用分布式锁，可满足分布式环境。

## 缓存雪崩
- 场景描述
    大量的key设置了相同的过期时间，导致在缓存在同一时刻全部失效，造成瞬时DB请求量大、压力骤增，引起雪崩。与击穿的区别：击穿是指同一条记录，而雪崩是指大量记录。最终结果都是大量请求发送到DB。
- 解决方案
    1.设置key永不过期（不建议）
    2.可以给缓存设置过期时间时加上一个随机值时间，使得每个key的过期时间分布开来，不会集中在同一时刻失效。

