{"meta":{"version":1,"warehouse":"5.0.1"},"models":{"Asset":[{"_id":"node_modules/hexo-theme-landscape/source/css/style.styl","path":"css/style.styl","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-landscape/source/fancybox/jquery.fancybox.min.css","path":"fancybox/jquery.fancybox.min.css","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-landscape/source/fancybox/jquery.fancybox.min.js","path":"fancybox/jquery.fancybox.min.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-landscape/source/js/jquery-3.6.4.min.js","path":"js/jquery-3.6.4.min.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-landscape/source/js/script.js","path":"js/script.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-landscape/source/css/images/banner.jpg","path":"css/images/banner.jpg","modified":0,"renderable":1},{"_id":"source/img/404-bg.jpg","path":"img/404-bg.jpg","modified":0,"renderable":0},{"_id":"source/img/beantech-desktop.png","path":"img/beantech-desktop.png","modified":0,"renderable":0},{"_id":"source/img/contact-bg.jpg","path":"img/contact-bg.jpg","modified":0,"renderable":0},{"_id":"source/img/icon_wechat.png","path":"img/icon_wechat.png","modified":0,"renderable":0},{"_id":"source/img/ironman-draw.png","path":"img/ironman-draw.png","modified":0,"renderable":0},{"_id":"source/img/nezha.jpg","path":"img/nezha.jpg","modified":0,"renderable":0},{"_id":"source/img/header_img/Iron-Man-3.jpg","path":"img/header_img/Iron-Man-3.jpg","modified":0,"renderable":0},{"_id":"source/img/header_img/archive-bg.png","path":"img/header_img/archive-bg.png","modified":0,"renderable":0},{"_id":"source/img/header_img/home-bg-2-dark.png","path":"img/header_img/home-bg-2-dark.png","modified":0,"renderable":0},{"_id":"source/img/header_img/home-bg-o.png","path":"img/header_img/home-bg-o.png","modified":0,"renderable":0},{"_id":"source/img/header_img/sunset-4379799_1920.jpg","path":"img/header_img/sunset-4379799_1920.jpg","modified":0,"renderable":0},{"_id":"source/img/header_img/tag-bg.png","path":"img/header_img/tag-bg.png","modified":0,"renderable":0},{"_id":"source/img/header_img/tf-logo-dark.png","path":"img/header_img/tf-logo-dark.png","modified":0,"renderable":0},{"_id":"source/img/signature/BeanTechSign-black.png","path":"img/signature/BeanTechSign-black.png","modified":0,"renderable":0},{"_id":"source/img/signature/BeanTechSign-white.png","path":"img/signature/BeanTechSign-white.png","modified":0,"renderable":0}],"Cache":[{"_id":"source/.DS_Store","hash":"b48c4f7d61a5928be717d4bd654481ff1eab36ee","modified":1709449228964},{"_id":"source/_posts/.DS_Store","hash":"df2fbeb1400acda0909a32c1cf6bf492f1121e07","modified":1709449228964},{"_id":"source/_posts/Oauth2-cors-设置.md","hash":"c9a6ca92a914d98761264db476bbe17428ed95c0","modified":1709449228964},{"_id":"source/_posts/Redis-缓存击穿、穿透、雪崩问题.md","hash":"fb479fec73b70ae0b507ece989880f4213e12f9a","modified":1709449228964},{"_id":"source/_posts/如何清楚的认识到自己的无知.md","hash":"ff53cc9b7e2dc3c321f661fefdd21b5db98cb943","modified":1709449228964},{"_id":"source/_posts/跨域请求设置说明.md","hash":"5150c8d03f68b1715b72553ff915119964290f9d","modified":1709449228964},{"_id":"source/img/icon_wechat.png","hash":"4188058026609de06c6cac88b349a2da831a1783","modified":1709450826000},{"_id":"source/img/nezha.jpg","hash":"57e163475e5f58c9afda6fc2002db82ec3b1cbc5","modified":1709450826006},{"_id":"source/img/header_img/Iron-Man-3.jpg","hash":"62a9a76854503c327990cc8d10de293ab6e9588f","modified":1709450826003},{"_id":"source/img/404-bg.jpg","hash":"68f7d525269a94287e0ad18713ae232fb59dcf71","modified":1709450826006},{"_id":"source/img/signature/BeanTechSign-white.png","hash":"34289ed41cf9ddac2d56be46fbb1515b7d5913cd","modified":1709450825999},{"_id":"source/img/ironman-draw.png","hash":"7d6a06b4b544ab146c3b3e8474edc33f14ac6e4d","modified":1709450826000},{"_id":"source/img/header_img/tf-logo-dark.png","hash":"5c7bf8ade9de134f8c77a3c59e575abe9fc6cdd4","modified":1709450826005},{"_id":"source/img/signature/BeanTechSign-black.png","hash":"94b7102e819fd6ee082d3fb0166f4de7458c22ff","modified":1709450825999},{"_id":"source/img/contact-bg.jpg","hash":"6af63305c923899017e727b5ca968a2703bc08cf","modified":1709450826006},{"_id":"source/img/header_img/sunset-4379799_1920.jpg","hash":"a98d965f8f30d1030281563e5aa1dfd24249eaea","modified":1709450826001},{"_id":"node_modules/hexo-theme-landscape/LICENSE","hash":"c480fce396b23997ee23cc535518ffaaf7f458f8","modified":1709449228144},{"_id":"node_modules/hexo-theme-landscape/package.json","hash":"4bf95d52f77edf811f23f6d264a7493311a8d078","modified":1709449228156},{"_id":"node_modules/hexo-theme-landscape/_config.yml","hash":"b608c1f1322760dce9805285a602a95832730a2e","modified":1709449228156},{"_id":"node_modules/hexo-theme-landscape/README.md","hash":"1a9b279e6dd29fd19245f913f0c4a316ffaa62db","modified":1709449228156},{"_id":"node_modules/hexo-theme-landscape/languages/de.yml","hash":"3ebf0775abbee928c8d7bda943c191d166ded0d3","modified":1709449228153},{"_id":"node_modules/hexo-theme-landscape/languages/default.yml","hash":"ea5e6aee4cb14510793ac4593a3bddffe23e530c","modified":1709449228152},{"_id":"node_modules/hexo-theme-landscape/languages/en-GB.yml","hash":"ea5e6aee4cb14510793ac4593a3bddffe23e530c","modified":1709449228155},{"_id":"node_modules/hexo-theme-landscape/languages/en-US.yml","hash":"ea5e6aee4cb14510793ac4593a3bddffe23e530c","modified":1709449228156},{"_id":"node_modules/hexo-theme-landscape/languages/de-DE.yml","hash":"d29d1c4256b7ed9df42f511c2ff0a23ad5fd6c1f","modified":1709449228155},{"_id":"node_modules/hexo-theme-landscape/languages/en.yml","hash":"3083f319b352d21d80fc5e20113ddf27889c9d11","modified":1709449228154},{"_id":"node_modules/hexo-theme-landscape/languages/es.yml","hash":"76edb1171b86532ef12cfd15f5f2c1ac3949f061","modified":1709449228153},{"_id":"node_modules/hexo-theme-landscape/languages/es-ES.yml","hash":"7008a8fc91f18d2a735864817b8ebda30c7a2c66","modified":1709449228154},{"_id":"node_modules/hexo-theme-landscape/languages/fr-FR.yml","hash":"8d09dbdab00a30a2870b56f7c0a7ca7deafa7b88","modified":1709449228155},{"_id":"node_modules/hexo-theme-landscape/languages/fr.yml","hash":"415e1c580ced8e4ce20b3b0aeedc3610341c76fb","modified":1709449228155},{"_id":"node_modules/hexo-theme-landscape/languages/hu-HU.yml","hash":"712d18664898fa21ba38d4973e90ef41a324ea25","modified":1709449228152},{"_id":"node_modules/hexo-theme-landscape/languages/it-IT.yml","hash":"2cb6dc2fab9bd2dbe1c8bb869a9e8bf85a564fdd","modified":1709449228154},{"_id":"node_modules/hexo-theme-landscape/languages/ja-JP.yml","hash":"08481267e0c112e1f6855620f2837ec4c4a98bbd","modified":1709449228154},{"_id":"node_modules/hexo-theme-landscape/languages/it.yml","hash":"89b7d91306b2c1a0f3ac023b657bf974f798a1e8","modified":1709449228154},{"_id":"node_modules/hexo-theme-landscape/languages/hu.yml","hash":"284d557130bf54a74e7dcef9d42096130e4d9550","modified":1709449228153},{"_id":"node_modules/hexo-theme-landscape/languages/ja.yml","hash":"a73e1b9c80fd6e930e2628b393bfe3fb716a21a9","modified":1709449228154},{"_id":"node_modules/hexo-theme-landscape/languages/ko.yml","hash":"881d6a0a101706e0452af81c580218e0bfddd9cf","modified":1709449228153},{"_id":"node_modules/hexo-theme-landscape/languages/ko-KR.yml","hash":"19209ad8f9d4057e8df808937f950eb265e1db69","modified":1709449228155},{"_id":"node_modules/hexo-theme-landscape/languages/mn-MN.yml","hash":"b9e5f3e7c0c2f779cf2cfded6db847b5941637ca","modified":1709449228152},{"_id":"node_modules/hexo-theme-landscape/languages/mn.yml","hash":"2e7523951072a9403ead3840ad823edd1084c116","modified":1709449228152},{"_id":"node_modules/hexo-theme-landscape/languages/nl-NL.yml","hash":"5ebbc30021f05d99938f96dfff280392df7f91f0","modified":1709449228154},{"_id":"node_modules/hexo-theme-landscape/languages/nl.yml","hash":"12ed59faba1fc4e8cdd1d42ab55ef518dde8039c","modified":1709449228156},{"_id":"node_modules/hexo-theme-landscape/languages/no.yml","hash":"965a171e70347215ec726952e63f5b47930931ef","modified":1709449228156},{"_id":"node_modules/hexo-theme-landscape/languages/pt-PT.yml","hash":"0f852b6b228e6ea59aa3540574bb89b233f2a098","modified":1709449228153},{"_id":"node_modules/hexo-theme-landscape/languages/ru.yml","hash":"4fda301bbd8b39f2c714e2c934eccc4b27c0a2b0","modified":1709449228155},{"_id":"node_modules/hexo-theme-landscape/languages/ru-RU.yml","hash":"360d11a28bb768afb1dd15f63fa7fd3a8cc547ee","modified":1709449228153},{"_id":"node_modules/hexo-theme-landscape/languages/pt.yml","hash":"57d07b75d434fbfc33b0ddb543021cb5f53318a8","modified":1709449228153},{"_id":"node_modules/hexo-theme-landscape/languages/th-TH.yml","hash":"ebfdba9bc4842c829473c1e6e4544344f182724d","modified":1709449228154},{"_id":"node_modules/hexo-theme-landscape/languages/th.yml","hash":"84a55b00aa01f03982be294e43c33a20e6d32862","modified":1709449228152},{"_id":"node_modules/hexo-theme-landscape/languages/tr.yml","hash":"a1cdbfa17682d7a971de8ab8588bf57c74224b5b","modified":1709449228155},{"_id":"node_modules/hexo-theme-landscape/languages/zh-CN.yml","hash":"1efd95774f401c80193eac6ee3f1794bfe93dc5a","modified":1709449228156},{"_id":"node_modules/hexo-theme-landscape/languages/zh-TW.yml","hash":"53ce3000c5f767759c7d2c4efcaa9049788599c3","modified":1709449228155},{"_id":"node_modules/hexo-theme-landscape/layout/archive.ejs","hash":"2703b07cc8ac64ae46d1d263f4653013c7e1666b","modified":1709449228145},{"_id":"node_modules/hexo-theme-landscape/layout/category.ejs","hash":"765426a9c8236828dc34759e604cc2c52292835a","modified":1709449228144},{"_id":"node_modules/hexo-theme-landscape/layout/layout.ejs","hash":"0d1765036e4874500e68256fedb7470e96eeb6ee","modified":1709449228145},{"_id":"node_modules/hexo-theme-landscape/layout/index.ejs","hash":"aa1b4456907bdb43e629be3931547e2d29ac58c8","modified":1709449228144},{"_id":"node_modules/hexo-theme-landscape/scripts/fancybox.js","hash":"c857d7a5e4a5d71c743a009c5932bf84229db428","modified":1709449228157},{"_id":"node_modules/hexo-theme-landscape/layout/page.ejs","hash":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1709449228147},{"_id":"node_modules/hexo-theme-landscape/layout/post.ejs","hash":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1709449228144},{"_id":"node_modules/hexo-theme-landscape/layout/tag.ejs","hash":"eaa7b4ccb2ca7befb90142e4e68995fb1ea68b2e","modified":1709449228145},{"_id":"node_modules/hexo-theme-landscape/layout/_partial/after-footer.ejs","hash":"377d257d5d16e0158a4405c72401517b074fd7ff","modified":1709449228147},{"_id":"node_modules/hexo-theme-landscape/layout/_partial/archive.ejs","hash":"7cb70a7a54f8c7ae49b10d1f37c0a9b74eab8826","modified":1709449228146},{"_id":"node_modules/hexo-theme-landscape/layout/_partial/archive-post.ejs","hash":"c7a71425a946d05414c069ec91811b5c09a92c47","modified":1709449228146},{"_id":"node_modules/hexo-theme-landscape/layout/_partial/article.ejs","hash":"56597e951203dd662a6d2c817c7c4f1c920d4a25","modified":1709449228147},{"_id":"node_modules/hexo-theme-landscape/layout/_partial/google-analytics.ejs","hash":"2ea7442ea1e1a8ab4e41e26c563f58413b59a3d0","modified":1709449228146},{"_id":"node_modules/hexo-theme-landscape/layout/_partial/gauges-analytics.ejs","hash":"21a1e2a3907d1a3dad1cd0ab855fe6735f233c74","modified":1709449228146},{"_id":"node_modules/hexo-theme-landscape/layout/_partial/head.ejs","hash":"f05bced793b0314d4f2ef0c993b3a51d0b7d203a","modified":1709449228147},{"_id":"node_modules/hexo-theme-landscape/layout/_partial/footer.ejs","hash":"3656eb692254346671abc03cb3ba1459829e0dce","modified":1709449228147},{"_id":"node_modules/hexo-theme-landscape/layout/_partial/header.ejs","hash":"6a5033d189554c9a6d42e2ef7952ae5c9742648e","modified":1709449228146},{"_id":"node_modules/hexo-theme-landscape/layout/_partial/mobile-nav.ejs","hash":"e952a532dfc583930a666b9d4479c32d4a84b44e","modified":1709449228147},{"_id":"node_modules/hexo-theme-landscape/layout/_widget/recent_posts.ejs","hash":"60c4b012dcc656438ff59997e60367e5a21ab746","modified":1709449228148},{"_id":"node_modules/hexo-theme-landscape/layout/_widget/tag.ejs","hash":"2de380865df9ab5f577f7d3bcadf44261eb5faae","modified":1709449228148},{"_id":"node_modules/hexo-theme-landscape/layout/_widget/category.ejs","hash":"dd1e5af3c6af3f5d6c85dfd5ca1766faed6a0b05","modified":1709449228148},{"_id":"node_modules/hexo-theme-landscape/layout/_widget/tagcloud.ejs","hash":"b4a2079101643f63993dcdb32925c9b071763b46","modified":1709449228148},{"_id":"node_modules/hexo-theme-landscape/source/css/_extend.styl","hash":"222fbe6d222531d61c1ef0f868c90f747b1c2ced","modified":1709449228151},{"_id":"node_modules/hexo-theme-landscape/layout/_partial/sidebar.ejs","hash":"930da35cc2d447a92e5ee8f835735e6fd2232469","modified":1709449228147},{"_id":"node_modules/hexo-theme-landscape/layout/_widget/archive.ejs","hash":"beb4a86fcc82a9bdda9289b59db5a1988918bec3","modified":1709449228148},{"_id":"node_modules/hexo-theme-landscape/source/css/style.styl","hash":"e55a1d92954ed20f6887f92dc727bb995a010a43","modified":1709449228151},{"_id":"node_modules/hexo-theme-landscape/source/css/_variables.styl","hash":"ca28281423ae57d76b6c1eb91cd845fd4e518bd6","modified":1709449228150},{"_id":"node_modules/hexo-theme-landscape/layout/_partial/post/category.ejs","hash":"c6bcd0e04271ffca81da25bcff5adf3d46f02fc0","modified":1709449228145},{"_id":"node_modules/hexo-theme-landscape/layout/_partial/post/date.ejs","hash":"f1458584b679545830b75bef2526e2f3eb931045","modified":1709449228146},{"_id":"node_modules/hexo-theme-landscape/layout/_partial/post/gallery.ejs","hash":"3d9d81a3c693ff2378ef06ddb6810254e509de5b","modified":1709449228146},{"_id":"node_modules/hexo-theme-landscape/source/js/script.js","hash":"49773efcb2221bbdf2d86f3f5c5ff2d841b528cc","modified":1709449228152},{"_id":"node_modules/hexo-theme-landscape/layout/_partial/post/nav.ejs","hash":"16a904de7bceccbb36b4267565f2215704db2880","modified":1709449228145},{"_id":"node_modules/hexo-theme-landscape/layout/_partial/post/tag.ejs","hash":"2fcb0bf9c8847a644167a27824c9bb19ac74dd14","modified":1709449228146},{"_id":"node_modules/hexo-theme-landscape/layout/_partial/post/title.ejs","hash":"4d7e62574ddf46de9b41605fe3140d77b5ddb26d","modified":1709449228145},{"_id":"node_modules/hexo-theme-landscape/source/css/_partial/archive.styl","hash":"db15f5677dc68f1730e82190bab69c24611ca292","modified":1709449228151},{"_id":"node_modules/hexo-theme-landscape/source/css/_partial/comment.styl","hash":"79d280d8d203abb3bd933ca9b8e38c78ec684987","modified":1709449228151},{"_id":"node_modules/hexo-theme-landscape/source/fancybox/jquery.fancybox.min.css","hash":"1be9b79be02a1cfc5d96c4a5e0feb8f472babd95","modified":1709449228149},{"_id":"node_modules/hexo-theme-landscape/source/css/_partial/footer.styl","hash":"e35a060b8512031048919709a8e7b1ec0e40bc1b","modified":1709449228150},{"_id":"node_modules/hexo-theme-landscape/source/css/_partial/header.styl","hash":"268d2989acb06e2ddd06cc36a6918c6cd865476b","modified":1709449228150},{"_id":"node_modules/hexo-theme-landscape/source/css/_partial/mobile.styl","hash":"a399cf9e1e1cec3e4269066e2948d7ae5854d745","modified":1709449228151},{"_id":"node_modules/hexo-theme-landscape/source/css/_partial/sidebar-aside.styl","hash":"890349df5145abf46ce7712010c89237900b3713","modified":1709449228151},{"_id":"node_modules/hexo-theme-landscape/source/css/_partial/highlight.styl","hash":"9cc3b2927d814f2f6e8e188f9d3657b94f4c6ef3","modified":1709449228150},{"_id":"node_modules/hexo-theme-landscape/source/css/_partial/sidebar-bottom.styl","hash":"8fd4f30d319542babfd31f087ddbac550f000a8a","modified":1709449228150},{"_id":"node_modules/hexo-theme-landscape/source/css/_partial/sidebar.styl","hash":"404ec059dc674a48b9ab89cd83f258dec4dcb24d","modified":1709449228150},{"_id":"node_modules/hexo-theme-landscape/source/css/_partial/article.styl","hash":"2d1f6f79ebf9cb55ebdb3865a2474437eb2b37c6","modified":1709449228150},{"_id":"node_modules/hexo-theme-landscape/source/css/_util/mixin.styl","hash":"44f32767d9fd3c1c08a60d91f181ee53c8f0dbb3","modified":1709449228149},{"_id":"node_modules/hexo-theme-landscape/source/css/_util/grid.styl","hash":"0bf55ee5d09f193e249083602ac5fcdb1e571aed","modified":1709449228149},{"_id":"node_modules/hexo-theme-landscape/source/fancybox/jquery.fancybox.min.js","hash":"6181412e73966696d08e1e5b1243a572d0f22ba6","modified":1709449228149},{"_id":"node_modules/hexo-theme-landscape/source/js/jquery-3.6.4.min.js","hash":"eda46747c71d38a880bee44f9a439c3858bb8f99","modified":1709449228152},{"_id":"node_modules/hexo-theme-landscape/source/css/images/banner.jpg","hash":"f44aa591089fcb3ec79770a1e102fd3289a7c6a6","modified":1709449228149},{"_id":"source/img/header_img/tag-bg.png","hash":"e83cd7b04ff85bcbc9bd3ebf5e57a55166e82568","modified":1709450826004},{"_id":"source/img/beantech-desktop.png","hash":"4a8f8b209c9db8fd5209f15b8e4590525e258b0f","modified":1709450826000},{"_id":"source/img/header_img/home-bg-o.png","hash":"134ece4cb4c49c7ca1403a5afe7f46d0e2f9ecbb","modified":1709450826003},{"_id":"source/img/header_img/home-bg-2-dark.png","hash":"da6a3d5ca787bdc25e69655abd879b4f821aeb30","modified":1709450826005},{"_id":"source/img/header_img/archive-bg.png","hash":"6bf9c224543ec54e250309db89cbdf46e0c4b5ba","modified":1709450826004},{"_id":"public/2019/08/06/Redis-缓存击穿、穿透、雪崩问题/index.html","hash":"9b55f74e0a210d7f110b448da544dd70eb5ee65b","modified":1709459982500},{"_id":"public/2019/08/08/如何清楚的认识到自己的无知/index.html","hash":"1cfbaae46a57f176578c5e74ae28c21b51b69c45","modified":1709459982500},{"_id":"public/2019/08/04/跨域请求设置说明/index.html","hash":"d5966ae0b865478a645604c2ed5823015725fb8c","modified":1709459982500},{"_id":"public/2019/08/04/Oauth2-cors-设置/index.html","hash":"39e64d535c30df302dbab5a6fccb20cb78769e71","modified":1709459982500},{"_id":"public/categories/web/index.html","hash":"afbf1948ae470cff81ef1ee3ee6389b0617a5ddf","modified":1709459982500},{"_id":"public/archives/index.html","hash":"8ad50ef99bf89444f66a92767eb5b713d8772f27","modified":1709459982500},{"_id":"public/archives/2019/index.html","hash":"d37133f4898d3ebb9bca8126cdc448fcd5e1d687","modified":1709459982500},{"_id":"public/archives/2019/08/index.html","hash":"2b8f74d8648fab121a1f3fd667662774120828eb","modified":1709459982500},{"_id":"public/index.html","hash":"8915b8c787ada07e6ce2c1f24da78f071cf3801a","modified":1709459982500},{"_id":"public/tags/spring-security/index.html","hash":"23ec4dd2fa59cb76419a9a70b1b260c795f1d74e","modified":1709459982500},{"_id":"public/tags/spring-oauth2/index.html","hash":"cbeb65fc538f2e1def6ae67ebd8db558e432ef8e","modified":1709459982500},{"_id":"public/tags/redis/index.html","hash":"081df9e41ef61ea1b8785bf8e963f3365c156211","modified":1709459982500},{"_id":"public/tags/生活/index.html","hash":"742698d06078bdd013cba7ed52b4d794c06241a5","modified":1709459982500},{"_id":"public/tags/http/index.html","hash":"6c36379982594475698e0b6f0dddd5777e46e11c","modified":1709459982500},{"_id":"public/tags/cors/index.html","hash":"8dc8f00eb9cd8308c06ea8b75ed63c21e076768d","modified":1709459982500},{"_id":"public/img/icon_wechat.png","hash":"4188058026609de06c6cac88b349a2da831a1783","modified":1709459982500},{"_id":"public/img/nezha.jpg","hash":"57e163475e5f58c9afda6fc2002db82ec3b1cbc5","modified":1709459982500},{"_id":"public/css/style.css","hash":"ddb3792605d744ab3d9f0a649c82b62e9b16daa6","modified":1709459982500},{"_id":"public/fancybox/jquery.fancybox.min.css","hash":"1be9b79be02a1cfc5d96c4a5e0feb8f472babd95","modified":1709459982500},{"_id":"public/fancybox/jquery.fancybox.min.js","hash":"6181412e73966696d08e1e5b1243a572d0f22ba6","modified":1709459982500},{"_id":"public/js/jquery-3.6.4.min.js","hash":"eda46747c71d38a880bee44f9a439c3858bb8f99","modified":1709459982500},{"_id":"public/js/script.js","hash":"49773efcb2221bbdf2d86f3f5c5ff2d841b528cc","modified":1709459982500},{"_id":"public/img/header_img/Iron-Man-3.jpg","hash":"62a9a76854503c327990cc8d10de293ab6e9588f","modified":1709459982500},{"_id":"public/img/404-bg.jpg","hash":"68f7d525269a94287e0ad18713ae232fb59dcf71","modified":1709459982500},{"_id":"public/img/signature/BeanTechSign-white.png","hash":"34289ed41cf9ddac2d56be46fbb1515b7d5913cd","modified":1709459982500},{"_id":"public/css/images/banner.jpg","hash":"f44aa591089fcb3ec79770a1e102fd3289a7c6a6","modified":1709459982500},{"_id":"public/img/ironman-draw.png","hash":"7d6a06b4b544ab146c3b3e8474edc33f14ac6e4d","modified":1709459982500},{"_id":"public/img/header_img/tf-logo-dark.png","hash":"5c7bf8ade9de134f8c77a3c59e575abe9fc6cdd4","modified":1709459982500},{"_id":"public/img/signature/BeanTechSign-black.png","hash":"94b7102e819fd6ee082d3fb0166f4de7458c22ff","modified":1709459982500},{"_id":"public/img/contact-bg.jpg","hash":"6af63305c923899017e727b5ca968a2703bc08cf","modified":1709459982500},{"_id":"public/img/header_img/sunset-4379799_1920.jpg","hash":"a98d965f8f30d1030281563e5aa1dfd24249eaea","modified":1709459982500},{"_id":"public/img/header_img/tag-bg.png","hash":"e83cd7b04ff85bcbc9bd3ebf5e57a55166e82568","modified":1709459982500},{"_id":"public/img/beantech-desktop.png","hash":"4a8f8b209c9db8fd5209f15b8e4590525e258b0f","modified":1709459982500},{"_id":"public/img/header_img/home-bg-o.png","hash":"134ece4cb4c49c7ca1403a5afe7f46d0e2f9ecbb","modified":1709459982500},{"_id":"public/img/header_img/home-bg-2-dark.png","hash":"da6a3d5ca787bdc25e69655abd879b4f821aeb30","modified":1709459982500},{"_id":"public/img/header_img/archive-bg.png","hash":"6bf9c224543ec54e250309db89cbdf46e0c4b5ba","modified":1709459982500}],"Category":[{"name":"web","_id":"cltbcc4gc00024o9vd3tyewbh"}],"Data":[],"Page":[],"Post":[{"title":"Oauth2 cors 设置","catalog":true,"subtitle":"spring oauth2 cors 设置简单记录","header-img":"http://pvpmnqrh8.bkt.clouddn.com/tag-bg.png","abbrlink":"e8cdb6bd","date":"2019-08-04T08:32:04.000Z","_content":"遇到的问题:\n>系统中同时使用了 spring security 与 spring oauth2 ，需要跨域支持。\n但是Spring security 的跨域设置未能覆盖到 oauth2 的token端点。\n\n## 分析过程与结果如下：\n根据spring 官方文档 security 的跨域设置方式：\n  ```\n  http.cors()\n```\n```\n    @Bean\n    public CorsConfigurationSource corsConfigurationSource () {\n        final UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource();\n        final CorsConfiguration config = new CorsConfiguration();\n        config.setAllowCredentials(false); // 禁止cookies跨域\n        config.addAllowedOrigin(\"*\");// 允许向该服务器提交请求的URI，*表示全部允许。。这里尽量限制来源域，比如http://xxxx:8080 ,以降低安全风险。。\n        config.addAllowedHeader(\"*\");// 允许访问的头信息,*表示全部\n        config.setMaxAge(18000L);// 预检请求的缓存时间（秒），即在这个时间段里，对于相同的跨域请求不会再预检了\n        config.addAllowedMethod(\"*\");// 允许提交请求的方法，*表示全部允许，也可以单独设置GET、PUT等\n        source.registerCorsConfiguration(\"/**\", config);\n        return source;\n    }\n```\n未生效,分析如下:\n由于 AuthorizationServer 的token 端点受httpBasic 认证限制。\n因此当跨域请求时。options 请求是不携带 认证信息的。\n导致跨域请求失败。\n如果需要设置 token端点 支持跨域。需要设置  处理跨域请求的filter order级别高于 0（小于0）。\n\n>注解@EnableAuthorizationServer 中关于security 鉴权的配置 由AuthorizationServerSecurityConfiguration 负责,代码如下：\n```\n@Target(ElementType.TYPE)\n@Retention(RetentionPolicy.RUNTIME)\n@Documented\n@Import({AuthorizationServerEndpointsConfiguration.class, AuthorizationServerSecurityConfiguration.class})\npublic @interface EnableAuthorizationServer\n```\n>AuthorizationServerSecurityConfiguration 配置类的代码如下：\n```\n@Configuration\n@Order(0)\n@Import({ClientDetailsServiceConfiguration.class, AuthorizationServerEndpointsConfiguration.class})\npublic class AuthorizationServerSecurityConfiguration extends WebSecurityConfigurerAdapter \n```\n- 具体 httpSecurity 配置可查看当前类-方法：\nprotected void configure(HttpSecurity http) throws Exception\n该类中定义了相关的 token端点安全配置。如果配置了spring security 文档中提供的跨域处理没有生效，就是因为该 filterChain中没有cors 的相关处理。\n\n因此如果需要 为oauth token端点添加 cors 配置。则需要设置cors filter的优先级别 高于 order(0).\n\n## 添加跨域方案: \n1.添加独立的cors filter，同时设置 优先级别高于 order(0)。\n- 可参考其他方案的 cors 添加方式，主要处理优先级\n\n2.定义自己的 @EnableAuthorizationServer 注解，重写其中 AuthorizationServerSecurityConfiguration 关于httpSecurity 相关配置，添加跨域处理。\n例子：\n```\n@Target(ElementType.TYPE)\n@Retention(RetentionPolicy.RUNTIME)\n@Documented\n@Import({ AuthorizationServerEndpointsConfiguration.class, PersonAuthorizationServerSecurityConfiguration.class })\npublic @interface EnablePersonAuthorizationServer {\n\n}\n```\n\n```\n@Configuration\n@Order(0)\n@Import({ ClientDetailsServiceConfiguration.class, AuthorizationServerEndpointsConfiguration.class })\npublic class PersonAuthorizationServerSecurityConfiguration extends AuthorizationServerSecurityConfiguration {\n\n    @Override\n    protected void configure(HttpSecurity http) throws Exception {\n        super.configure(http);\n        http.cors();\n    }\n}\n```\n\n```\n    @Bean\n    CorsConfigurationSource corsConfigurationSource(OAuth2PlatformCorsConfig oauth2PlatformCorsConfig) {\n        CorsConfiguration configuration = new CorsConfiguration();\n        configuration.setAllowedOrigins(\"*\");\n        configuration.setAllowedMethods(\"*\");\n        configuration.setAllowedHeaders(\"*\");\n        configuration.setMaxAge(36000);\n        configuration.setAllowCredentials(true);\n        UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource();\n        source.registerCorsConfiguration(\"/**\", configuration);\n        return source;\n    }\n    ```\n\n总结：\n核心思想解决方式：要求处理跨域的filter优先级别高于 spring oauth2自身的 httpBasic鉴权filter优先级。将跨域的options 请求，拦截处理。（因为spirng oauth2的token端点受httpBasic认证校验）。只有这样cors filter 才能正确生效。","source":"_posts/Oauth2-cors-设置.md","raw":"---\ntitle: Oauth2 cors 设置\ncatalog: true\nsubtitle: spring oauth2 cors 设置简单记录\nheader-img: 'http://pvpmnqrh8.bkt.clouddn.com/tag-bg.png'\ntags:\n  - spring security\n  - spring oauth2\ncategories:\n  - web\nabbrlink: e8cdb6bd\ndate: 2019-08-04 16:32:04\n---\n遇到的问题:\n>系统中同时使用了 spring security 与 spring oauth2 ，需要跨域支持。\n但是Spring security 的跨域设置未能覆盖到 oauth2 的token端点。\n\n## 分析过程与结果如下：\n根据spring 官方文档 security 的跨域设置方式：\n  ```\n  http.cors()\n```\n```\n    @Bean\n    public CorsConfigurationSource corsConfigurationSource () {\n        final UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource();\n        final CorsConfiguration config = new CorsConfiguration();\n        config.setAllowCredentials(false); // 禁止cookies跨域\n        config.addAllowedOrigin(\"*\");// 允许向该服务器提交请求的URI，*表示全部允许。。这里尽量限制来源域，比如http://xxxx:8080 ,以降低安全风险。。\n        config.addAllowedHeader(\"*\");// 允许访问的头信息,*表示全部\n        config.setMaxAge(18000L);// 预检请求的缓存时间（秒），即在这个时间段里，对于相同的跨域请求不会再预检了\n        config.addAllowedMethod(\"*\");// 允许提交请求的方法，*表示全部允许，也可以单独设置GET、PUT等\n        source.registerCorsConfiguration(\"/**\", config);\n        return source;\n    }\n```\n未生效,分析如下:\n由于 AuthorizationServer 的token 端点受httpBasic 认证限制。\n因此当跨域请求时。options 请求是不携带 认证信息的。\n导致跨域请求失败。\n如果需要设置 token端点 支持跨域。需要设置  处理跨域请求的filter order级别高于 0（小于0）。\n\n>注解@EnableAuthorizationServer 中关于security 鉴权的配置 由AuthorizationServerSecurityConfiguration 负责,代码如下：\n```\n@Target(ElementType.TYPE)\n@Retention(RetentionPolicy.RUNTIME)\n@Documented\n@Import({AuthorizationServerEndpointsConfiguration.class, AuthorizationServerSecurityConfiguration.class})\npublic @interface EnableAuthorizationServer\n```\n>AuthorizationServerSecurityConfiguration 配置类的代码如下：\n```\n@Configuration\n@Order(0)\n@Import({ClientDetailsServiceConfiguration.class, AuthorizationServerEndpointsConfiguration.class})\npublic class AuthorizationServerSecurityConfiguration extends WebSecurityConfigurerAdapter \n```\n- 具体 httpSecurity 配置可查看当前类-方法：\nprotected void configure(HttpSecurity http) throws Exception\n该类中定义了相关的 token端点安全配置。如果配置了spring security 文档中提供的跨域处理没有生效，就是因为该 filterChain中没有cors 的相关处理。\n\n因此如果需要 为oauth token端点添加 cors 配置。则需要设置cors filter的优先级别 高于 order(0).\n\n## 添加跨域方案: \n1.添加独立的cors filter，同时设置 优先级别高于 order(0)。\n- 可参考其他方案的 cors 添加方式，主要处理优先级\n\n2.定义自己的 @EnableAuthorizationServer 注解，重写其中 AuthorizationServerSecurityConfiguration 关于httpSecurity 相关配置，添加跨域处理。\n例子：\n```\n@Target(ElementType.TYPE)\n@Retention(RetentionPolicy.RUNTIME)\n@Documented\n@Import({ AuthorizationServerEndpointsConfiguration.class, PersonAuthorizationServerSecurityConfiguration.class })\npublic @interface EnablePersonAuthorizationServer {\n\n}\n```\n\n```\n@Configuration\n@Order(0)\n@Import({ ClientDetailsServiceConfiguration.class, AuthorizationServerEndpointsConfiguration.class })\npublic class PersonAuthorizationServerSecurityConfiguration extends AuthorizationServerSecurityConfiguration {\n\n    @Override\n    protected void configure(HttpSecurity http) throws Exception {\n        super.configure(http);\n        http.cors();\n    }\n}\n```\n\n```\n    @Bean\n    CorsConfigurationSource corsConfigurationSource(OAuth2PlatformCorsConfig oauth2PlatformCorsConfig) {\n        CorsConfiguration configuration = new CorsConfiguration();\n        configuration.setAllowedOrigins(\"*\");\n        configuration.setAllowedMethods(\"*\");\n        configuration.setAllowedHeaders(\"*\");\n        configuration.setMaxAge(36000);\n        configuration.setAllowCredentials(true);\n        UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource();\n        source.registerCorsConfiguration(\"/**\", configuration);\n        return source;\n    }\n    ```\n\n总结：\n核心思想解决方式：要求处理跨域的filter优先级别高于 spring oauth2自身的 httpBasic鉴权filter优先级。将跨域的options 请求，拦截处理。（因为spirng oauth2的token端点受httpBasic认证校验）。只有这样cors filter 才能正确生效。","slug":"Oauth2-cors-设置","published":1,"updated":"2024-03-03T07:00:28.964Z","comments":1,"layout":"post","photos":[],"_id":"cltbcc4g200004o9v07an6y4b","content":"<p>遇到的问题:</p>\n<blockquote>\n<p>系统中同时使用了 spring security 与 spring oauth2 ，需要跨域支持。<br>但是Spring security 的跨域设置未能覆盖到 oauth2 的token端点。</p>\n</blockquote>\n<h2 id=\"分析过程与结果如下：\"><a href=\"#分析过程与结果如下：\" class=\"headerlink\" title=\"分析过程与结果如下：\"></a>分析过程与结果如下：</h2><p>根据spring 官方文档 security 的跨域设置方式：<br>  <figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">http.cors()</span><br></pre></td></tr></table></figure></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Bean</span><br><span class=\"line\">public CorsConfigurationSource corsConfigurationSource () &#123;</span><br><span class=\"line\">    final UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource();</span><br><span class=\"line\">    final CorsConfiguration config = new CorsConfiguration();</span><br><span class=\"line\">    config.setAllowCredentials(false); // 禁止cookies跨域</span><br><span class=\"line\">    config.addAllowedOrigin(&quot;*&quot;);// 允许向该服务器提交请求的URI，*表示全部允许。。这里尽量限制来源域，比如http://xxxx:8080 ,以降低安全风险。。</span><br><span class=\"line\">    config.addAllowedHeader(&quot;*&quot;);// 允许访问的头信息,*表示全部</span><br><span class=\"line\">    config.setMaxAge(18000L);// 预检请求的缓存时间（秒），即在这个时间段里，对于相同的跨域请求不会再预检了</span><br><span class=\"line\">    config.addAllowedMethod(&quot;*&quot;);// 允许提交请求的方法，*表示全部允许，也可以单独设置GET、PUT等</span><br><span class=\"line\">    source.registerCorsConfiguration(&quot;/**&quot;, config);</span><br><span class=\"line\">    return source;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>未生效,分析如下:<br>由于 AuthorizationServer 的token 端点受httpBasic 认证限制。<br>因此当跨域请求时。options 请求是不携带 认证信息的。<br>导致跨域请求失败。<br>如果需要设置 token端点 支持跨域。需要设置  处理跨域请求的filter order级别高于 0（小于0）。</p>\n<blockquote>\n<p>注解@EnableAuthorizationServer 中关于security 鉴权的配置 由AuthorizationServerSecurityConfiguration 负责,代码如下：</p>\n</blockquote>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Target(ElementType.TYPE)</span><br><span class=\"line\">@Retention(RetentionPolicy.RUNTIME)</span><br><span class=\"line\">@Documented</span><br><span class=\"line\">@Import(&#123;AuthorizationServerEndpointsConfiguration.class, AuthorizationServerSecurityConfiguration.class&#125;)</span><br><span class=\"line\">public @interface EnableAuthorizationServer</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>AuthorizationServerSecurityConfiguration 配置类的代码如下：</p>\n</blockquote>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Configuration</span><br><span class=\"line\">@Order(0)</span><br><span class=\"line\">@Import(&#123;ClientDetailsServiceConfiguration.class, AuthorizationServerEndpointsConfiguration.class&#125;)</span><br><span class=\"line\">public class AuthorizationServerSecurityConfiguration extends WebSecurityConfigurerAdapter </span><br></pre></td></tr></table></figure>\n<ul>\n<li>具体 httpSecurity 配置可查看当前类-方法：<br>protected void configure(HttpSecurity http) throws Exception<br>该类中定义了相关的 token端点安全配置。如果配置了spring security 文档中提供的跨域处理没有生效，就是因为该 filterChain中没有cors 的相关处理。</li>\n</ul>\n<p>因此如果需要 为oauth token端点添加 cors 配置。则需要设置cors filter的优先级别 高于 order(0).</p>\n<h2 id=\"添加跨域方案\"><a href=\"#添加跨域方案\" class=\"headerlink\" title=\"添加跨域方案:\"></a>添加跨域方案:</h2><p>1.添加独立的cors filter，同时设置 优先级别高于 order(0)。</p>\n<ul>\n<li>可参考其他方案的 cors 添加方式，主要处理优先级</li>\n</ul>\n<p>2.定义自己的 @EnableAuthorizationServer 注解，重写其中 AuthorizationServerSecurityConfiguration 关于httpSecurity 相关配置，添加跨域处理。<br>例子：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Target(ElementType.TYPE)</span><br><span class=\"line\">@Retention(RetentionPolicy.RUNTIME)</span><br><span class=\"line\">@Documented</span><br><span class=\"line\">@Import(&#123; AuthorizationServerEndpointsConfiguration.class, PersonAuthorizationServerSecurityConfiguration.class &#125;)</span><br><span class=\"line\">public @interface EnablePersonAuthorizationServer &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Configuration</span><br><span class=\"line\">@Order(0)</span><br><span class=\"line\">@Import(&#123; ClientDetailsServiceConfiguration.class, AuthorizationServerEndpointsConfiguration.class &#125;)</span><br><span class=\"line\">public class PersonAuthorizationServerSecurityConfiguration extends AuthorizationServerSecurityConfiguration &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    protected void configure(HttpSecurity http) throws Exception &#123;</span><br><span class=\"line\">        super.configure(http);</span><br><span class=\"line\">        http.cors();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Bean</span><br><span class=\"line\">CorsConfigurationSource corsConfigurationSource(OAuth2PlatformCorsConfig oauth2PlatformCorsConfig) &#123;</span><br><span class=\"line\">    CorsConfiguration configuration = new CorsConfiguration();</span><br><span class=\"line\">    configuration.setAllowedOrigins(&quot;*&quot;);</span><br><span class=\"line\">    configuration.setAllowedMethods(&quot;*&quot;);</span><br><span class=\"line\">    configuration.setAllowedHeaders(&quot;*&quot;);</span><br><span class=\"line\">    configuration.setMaxAge(36000);</span><br><span class=\"line\">    configuration.setAllowCredentials(true);</span><br><span class=\"line\">    UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource();</span><br><span class=\"line\">    source.registerCorsConfiguration(&quot;/**&quot;, configuration);</span><br><span class=\"line\">    return source;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>总结：<br>核心思想解决方式：要求处理跨域的filter优先级别高于 spring oauth2自身的 httpBasic鉴权filter优先级。将跨域的options 请求，拦截处理。（因为spirng oauth2的token端点受httpBasic认证校验）。只有这样cors filter 才能正确生效。</p>\n","excerpt":"","more":"<p>遇到的问题:</p>\n<blockquote>\n<p>系统中同时使用了 spring security 与 spring oauth2 ，需要跨域支持。<br>但是Spring security 的跨域设置未能覆盖到 oauth2 的token端点。</p>\n</blockquote>\n<h2 id=\"分析过程与结果如下：\"><a href=\"#分析过程与结果如下：\" class=\"headerlink\" title=\"分析过程与结果如下：\"></a>分析过程与结果如下：</h2><p>根据spring 官方文档 security 的跨域设置方式：<br>  <figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">http.cors()</span><br></pre></td></tr></table></figure></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Bean</span><br><span class=\"line\">public CorsConfigurationSource corsConfigurationSource () &#123;</span><br><span class=\"line\">    final UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource();</span><br><span class=\"line\">    final CorsConfiguration config = new CorsConfiguration();</span><br><span class=\"line\">    config.setAllowCredentials(false); // 禁止cookies跨域</span><br><span class=\"line\">    config.addAllowedOrigin(&quot;*&quot;);// 允许向该服务器提交请求的URI，*表示全部允许。。这里尽量限制来源域，比如http://xxxx:8080 ,以降低安全风险。。</span><br><span class=\"line\">    config.addAllowedHeader(&quot;*&quot;);// 允许访问的头信息,*表示全部</span><br><span class=\"line\">    config.setMaxAge(18000L);// 预检请求的缓存时间（秒），即在这个时间段里，对于相同的跨域请求不会再预检了</span><br><span class=\"line\">    config.addAllowedMethod(&quot;*&quot;);// 允许提交请求的方法，*表示全部允许，也可以单独设置GET、PUT等</span><br><span class=\"line\">    source.registerCorsConfiguration(&quot;/**&quot;, config);</span><br><span class=\"line\">    return source;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>未生效,分析如下:<br>由于 AuthorizationServer 的token 端点受httpBasic 认证限制。<br>因此当跨域请求时。options 请求是不携带 认证信息的。<br>导致跨域请求失败。<br>如果需要设置 token端点 支持跨域。需要设置  处理跨域请求的filter order级别高于 0（小于0）。</p>\n<blockquote>\n<p>注解@EnableAuthorizationServer 中关于security 鉴权的配置 由AuthorizationServerSecurityConfiguration 负责,代码如下：</p>\n</blockquote>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Target(ElementType.TYPE)</span><br><span class=\"line\">@Retention(RetentionPolicy.RUNTIME)</span><br><span class=\"line\">@Documented</span><br><span class=\"line\">@Import(&#123;AuthorizationServerEndpointsConfiguration.class, AuthorizationServerSecurityConfiguration.class&#125;)</span><br><span class=\"line\">public @interface EnableAuthorizationServer</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>AuthorizationServerSecurityConfiguration 配置类的代码如下：</p>\n</blockquote>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Configuration</span><br><span class=\"line\">@Order(0)</span><br><span class=\"line\">@Import(&#123;ClientDetailsServiceConfiguration.class, AuthorizationServerEndpointsConfiguration.class&#125;)</span><br><span class=\"line\">public class AuthorizationServerSecurityConfiguration extends WebSecurityConfigurerAdapter </span><br></pre></td></tr></table></figure>\n<ul>\n<li>具体 httpSecurity 配置可查看当前类-方法：<br>protected void configure(HttpSecurity http) throws Exception<br>该类中定义了相关的 token端点安全配置。如果配置了spring security 文档中提供的跨域处理没有生效，就是因为该 filterChain中没有cors 的相关处理。</li>\n</ul>\n<p>因此如果需要 为oauth token端点添加 cors 配置。则需要设置cors filter的优先级别 高于 order(0).</p>\n<h2 id=\"添加跨域方案\"><a href=\"#添加跨域方案\" class=\"headerlink\" title=\"添加跨域方案:\"></a>添加跨域方案:</h2><p>1.添加独立的cors filter，同时设置 优先级别高于 order(0)。</p>\n<ul>\n<li>可参考其他方案的 cors 添加方式，主要处理优先级</li>\n</ul>\n<p>2.定义自己的 @EnableAuthorizationServer 注解，重写其中 AuthorizationServerSecurityConfiguration 关于httpSecurity 相关配置，添加跨域处理。<br>例子：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Target(ElementType.TYPE)</span><br><span class=\"line\">@Retention(RetentionPolicy.RUNTIME)</span><br><span class=\"line\">@Documented</span><br><span class=\"line\">@Import(&#123; AuthorizationServerEndpointsConfiguration.class, PersonAuthorizationServerSecurityConfiguration.class &#125;)</span><br><span class=\"line\">public @interface EnablePersonAuthorizationServer &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Configuration</span><br><span class=\"line\">@Order(0)</span><br><span class=\"line\">@Import(&#123; ClientDetailsServiceConfiguration.class, AuthorizationServerEndpointsConfiguration.class &#125;)</span><br><span class=\"line\">public class PersonAuthorizationServerSecurityConfiguration extends AuthorizationServerSecurityConfiguration &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    protected void configure(HttpSecurity http) throws Exception &#123;</span><br><span class=\"line\">        super.configure(http);</span><br><span class=\"line\">        http.cors();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Bean</span><br><span class=\"line\">CorsConfigurationSource corsConfigurationSource(OAuth2PlatformCorsConfig oauth2PlatformCorsConfig) &#123;</span><br><span class=\"line\">    CorsConfiguration configuration = new CorsConfiguration();</span><br><span class=\"line\">    configuration.setAllowedOrigins(&quot;*&quot;);</span><br><span class=\"line\">    configuration.setAllowedMethods(&quot;*&quot;);</span><br><span class=\"line\">    configuration.setAllowedHeaders(&quot;*&quot;);</span><br><span class=\"line\">    configuration.setMaxAge(36000);</span><br><span class=\"line\">    configuration.setAllowCredentials(true);</span><br><span class=\"line\">    UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource();</span><br><span class=\"line\">    source.registerCorsConfiguration(&quot;/**&quot;, configuration);</span><br><span class=\"line\">    return source;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>总结：<br>核心思想解决方式：要求处理跨域的filter优先级别高于 spring oauth2自身的 httpBasic鉴权filter优先级。将跨域的options 请求，拦截处理。（因为spirng oauth2的token端点受httpBasic认证校验）。只有这样cors filter 才能正确生效。</p>\n"},{"title":"Redis 缓存击穿、穿透、雪崩问题","catalog":true,"subtitle":"redis 缓存击穿等简单分析","header-img":"http://pvpmnqrh8.bkt.clouddn.com/tag-bg.png","abbrlink":"7b82129d","date":"2019-08-06T02:55:39.000Z","_content":"\n## 正常缓存工作流程\n当用户请求某资源时，首先查看是否命中缓存。若命中，直接返回缓存数据。若未命中，则去数据存储中查询当数据返回，并放入缓存中。以便下回再次请求该资源，可命中缓存。降低底层存储压力。\n\n## 缓存穿透\n- 场景描述\n     当用户请求某个一定不存在的资源时，该请求一定无法命中缓存，因此每次请求都会打到底层存储。同时底层存储中也不存在该资源，无法更新缓存。这就导致了这个不存在的资源请求，每一次都会到底层存储去查询，缓存失效。如果有大量的此类请求，可能会导致DB挂掉，服务中断。\n\n- 解决方案\n    1.当用户请求了不存在的数据时，我们可以将从底层存储中查询到的空值或自定义的无效代码存入redis中，但是需要设置一个较短的失效时间（可是分钟级别的，不宜太长或太短）。\n    2.采用布隆过滤器,将所有可能存在的数据哈希到一个足够大的bitmap中,一个一定不存在的数据会被这个bitmap拦截掉,从而避免了对底层存储系统的查询压力.\n\n## 缓存击穿\n- 场景描述\n    根据正常的缓存工作流程，首先查询redis缓存中是否存在，在未命中缓存时去查询数据库中的数据，并将数据放入redis中。\n    但是如果存在某个高并发的key，该key在某个时间过期了。同时该时间点，有大量关于该key的请求进入系统。发现在redis中不存在该数据，所有的请求都会到DB中去访问。瞬时的请求可能将DB打死，造成服务中断。\n\n- 解决方案\n    1.设置key 永不过期（不建议）\n    2.添加互斥锁，保证只有一条请求去查询数据库，并更新缓存。（只能保证单机）\n    3.使用分布式锁，可满足分布式环境。\n\n## 缓存雪崩\n- 场景描述\n    大量的key设置了相同的过期时间，导致在缓存在同一时刻全部失效，造成瞬时DB请求量大、压力骤增，引起雪崩。与击穿的区别：击穿是指同一条记录，而雪崩是指大量记录。最终结果都是大量请求发送到DB。\n- 解决方案\n    1.设置key永不过期（不建议）\n    2.可以给缓存设置过期时间时加上一个随机值时间，使得每个key的过期时间分布开来，不会集中在同一时刻失效。\n\n","source":"_posts/Redis-缓存击穿、穿透、雪崩问题.md","raw":"---\ntitle: Redis 缓存击穿、穿透、雪崩问题\ncatalog: true\nsubtitle: redis 缓存击穿等简单分析\nheader-img: 'http://pvpmnqrh8.bkt.clouddn.com/tag-bg.png'\ntags:\n  - redis\ncategories:\n  - web\nabbrlink: 7b82129d\ndate: 2019-08-06 10:55:39\n---\n\n## 正常缓存工作流程\n当用户请求某资源时，首先查看是否命中缓存。若命中，直接返回缓存数据。若未命中，则去数据存储中查询当数据返回，并放入缓存中。以便下回再次请求该资源，可命中缓存。降低底层存储压力。\n\n## 缓存穿透\n- 场景描述\n     当用户请求某个一定不存在的资源时，该请求一定无法命中缓存，因此每次请求都会打到底层存储。同时底层存储中也不存在该资源，无法更新缓存。这就导致了这个不存在的资源请求，每一次都会到底层存储去查询，缓存失效。如果有大量的此类请求，可能会导致DB挂掉，服务中断。\n\n- 解决方案\n    1.当用户请求了不存在的数据时，我们可以将从底层存储中查询到的空值或自定义的无效代码存入redis中，但是需要设置一个较短的失效时间（可是分钟级别的，不宜太长或太短）。\n    2.采用布隆过滤器,将所有可能存在的数据哈希到一个足够大的bitmap中,一个一定不存在的数据会被这个bitmap拦截掉,从而避免了对底层存储系统的查询压力.\n\n## 缓存击穿\n- 场景描述\n    根据正常的缓存工作流程，首先查询redis缓存中是否存在，在未命中缓存时去查询数据库中的数据，并将数据放入redis中。\n    但是如果存在某个高并发的key，该key在某个时间过期了。同时该时间点，有大量关于该key的请求进入系统。发现在redis中不存在该数据，所有的请求都会到DB中去访问。瞬时的请求可能将DB打死，造成服务中断。\n\n- 解决方案\n    1.设置key 永不过期（不建议）\n    2.添加互斥锁，保证只有一条请求去查询数据库，并更新缓存。（只能保证单机）\n    3.使用分布式锁，可满足分布式环境。\n\n## 缓存雪崩\n- 场景描述\n    大量的key设置了相同的过期时间，导致在缓存在同一时刻全部失效，造成瞬时DB请求量大、压力骤增，引起雪崩。与击穿的区别：击穿是指同一条记录，而雪崩是指大量记录。最终结果都是大量请求发送到DB。\n- 解决方案\n    1.设置key永不过期（不建议）\n    2.可以给缓存设置过期时间时加上一个随机值时间，使得每个key的过期时间分布开来，不会集中在同一时刻失效。\n\n","slug":"Redis-缓存击穿、穿透、雪崩问题","published":1,"updated":"2024-03-03T07:00:28.964Z","comments":1,"layout":"post","photos":[],"_id":"cltbcc4g900014o9vgopeau0c","content":"<h2 id=\"正常缓存工作流程\"><a href=\"#正常缓存工作流程\" class=\"headerlink\" title=\"正常缓存工作流程\"></a>正常缓存工作流程</h2><p>当用户请求某资源时，首先查看是否命中缓存。若命中，直接返回缓存数据。若未命中，则去数据存储中查询当数据返回，并放入缓存中。以便下回再次请求该资源，可命中缓存。降低底层存储压力。</p>\n<h2 id=\"缓存穿透\"><a href=\"#缓存穿透\" class=\"headerlink\" title=\"缓存穿透\"></a>缓存穿透</h2><ul>\n<li><p>场景描述<br>   当用户请求某个一定不存在的资源时，该请求一定无法命中缓存，因此每次请求都会打到底层存储。同时底层存储中也不存在该资源，无法更新缓存。这就导致了这个不存在的资源请求，每一次都会到底层存储去查询，缓存失效。如果有大量的此类请求，可能会导致DB挂掉，服务中断。</p>\n</li>\n<li><p>解决方案<br>  1.当用户请求了不存在的数据时，我们可以将从底层存储中查询到的空值或自定义的无效代码存入redis中，但是需要设置一个较短的失效时间（可是分钟级别的，不宜太长或太短）。<br>  2.采用布隆过滤器,将所有可能存在的数据哈希到一个足够大的bitmap中,一个一定不存在的数据会被这个bitmap拦截掉,从而避免了对底层存储系统的查询压力.</p>\n</li>\n</ul>\n<h2 id=\"缓存击穿\"><a href=\"#缓存击穿\" class=\"headerlink\" title=\"缓存击穿\"></a>缓存击穿</h2><ul>\n<li><p>场景描述<br>  根据正常的缓存工作流程，首先查询redis缓存中是否存在，在未命中缓存时去查询数据库中的数据，并将数据放入redis中。<br>  但是如果存在某个高并发的key，该key在某个时间过期了。同时该时间点，有大量关于该key的请求进入系统。发现在redis中不存在该数据，所有的请求都会到DB中去访问。瞬时的请求可能将DB打死，造成服务中断。</p>\n</li>\n<li><p>解决方案<br>  1.设置key 永不过期（不建议）<br>  2.添加互斥锁，保证只有一条请求去查询数据库，并更新缓存。（只能保证单机）<br>  3.使用分布式锁，可满足分布式环境。</p>\n</li>\n</ul>\n<h2 id=\"缓存雪崩\"><a href=\"#缓存雪崩\" class=\"headerlink\" title=\"缓存雪崩\"></a>缓存雪崩</h2><ul>\n<li>场景描述<br>  大量的key设置了相同的过期时间，导致在缓存在同一时刻全部失效，造成瞬时DB请求量大、压力骤增，引起雪崩。与击穿的区别：击穿是指同一条记录，而雪崩是指大量记录。最终结果都是大量请求发送到DB。</li>\n<li>解决方案<br>  1.设置key永不过期（不建议）<br>  2.可以给缓存设置过期时间时加上一个随机值时间，使得每个key的过期时间分布开来，不会集中在同一时刻失效。</li>\n</ul>\n","excerpt":"","more":"<h2 id=\"正常缓存工作流程\"><a href=\"#正常缓存工作流程\" class=\"headerlink\" title=\"正常缓存工作流程\"></a>正常缓存工作流程</h2><p>当用户请求某资源时，首先查看是否命中缓存。若命中，直接返回缓存数据。若未命中，则去数据存储中查询当数据返回，并放入缓存中。以便下回再次请求该资源，可命中缓存。降低底层存储压力。</p>\n<h2 id=\"缓存穿透\"><a href=\"#缓存穿透\" class=\"headerlink\" title=\"缓存穿透\"></a>缓存穿透</h2><ul>\n<li><p>场景描述<br>   当用户请求某个一定不存在的资源时，该请求一定无法命中缓存，因此每次请求都会打到底层存储。同时底层存储中也不存在该资源，无法更新缓存。这就导致了这个不存在的资源请求，每一次都会到底层存储去查询，缓存失效。如果有大量的此类请求，可能会导致DB挂掉，服务中断。</p>\n</li>\n<li><p>解决方案<br>  1.当用户请求了不存在的数据时，我们可以将从底层存储中查询到的空值或自定义的无效代码存入redis中，但是需要设置一个较短的失效时间（可是分钟级别的，不宜太长或太短）。<br>  2.采用布隆过滤器,将所有可能存在的数据哈希到一个足够大的bitmap中,一个一定不存在的数据会被这个bitmap拦截掉,从而避免了对底层存储系统的查询压力.</p>\n</li>\n</ul>\n<h2 id=\"缓存击穿\"><a href=\"#缓存击穿\" class=\"headerlink\" title=\"缓存击穿\"></a>缓存击穿</h2><ul>\n<li><p>场景描述<br>  根据正常的缓存工作流程，首先查询redis缓存中是否存在，在未命中缓存时去查询数据库中的数据，并将数据放入redis中。<br>  但是如果存在某个高并发的key，该key在某个时间过期了。同时该时间点，有大量关于该key的请求进入系统。发现在redis中不存在该数据，所有的请求都会到DB中去访问。瞬时的请求可能将DB打死，造成服务中断。</p>\n</li>\n<li><p>解决方案<br>  1.设置key 永不过期（不建议）<br>  2.添加互斥锁，保证只有一条请求去查询数据库，并更新缓存。（只能保证单机）<br>  3.使用分布式锁，可满足分布式环境。</p>\n</li>\n</ul>\n<h2 id=\"缓存雪崩\"><a href=\"#缓存雪崩\" class=\"headerlink\" title=\"缓存雪崩\"></a>缓存雪崩</h2><ul>\n<li>场景描述<br>  大量的key设置了相同的过期时间，导致在缓存在同一时刻全部失效，造成瞬时DB请求量大、压力骤增，引起雪崩。与击穿的区别：击穿是指同一条记录，而雪崩是指大量记录。最终结果都是大量请求发送到DB。</li>\n<li>解决方案<br>  1.设置key永不过期（不建议）<br>  2.可以给缓存设置过期时间时加上一个随机值时间，使得每个key的过期时间分布开来，不会集中在同一时刻失效。</li>\n</ul>\n"},{"title":"如何清楚的认识到自己的无知","catalog":true,"subtitle":"也许我们都忘记了‘井底之蛙的故事’。一个大家都记得，但是没有再思考过的故事。","header-img":"http://pvpmnqrh8.bkt.clouddn.com/rain-4376988_1280.jpg","categroies":["随笔"],"abbrlink":"7460b142","date":"2019-08-08T07:10:30.000Z","_content":"## 井底之蛙\n\n>\"井蛙不可以语于海者，拘于虚也。\" --《庄子·秋水》\n\n![image](http://pvpmnqrh8.bkt.clouddn.com/u=3393515458,1954360820&fm=26&gp=0.jpg)\n\n一只青蛙它拥有一口井。我们作为一个人，又拥有什么呢。我们拥有比青蛙更聪明的大脑。然而大部分情况下，我们跟青蛙一样坐井观天。\n\n井底之蛙的故事大家都清楚，同时我相信没有一个人会把这个故事忘了。故事的道理大家也都清楚。但是也许大部分人都没有从这个故事中获得应该得到的。原因或许是：鸟在井边，蛙在井里，人在画外罢了。我们将自己摆在了一个高于两者的位置上。\n我们认为我们懂得比那个无知的青蛙多，我们认为我们比鸟看的更高。也许我们应该保持自己的对无知的敬畏，才能使自己不成为那只青蛙吧。\n\n![image](http://pvpmnqrh8.bkt.clouddn.com/3421338-6bc1c9302d4e74bb.jpg)\n\n> 整个世界的问题在于，愚者和狂徒对自己总是如此确信，而智者则满是疑虑。——伯特兰·罗素\n\n\n'高估自己'、'过度自信'，这种现象在心理学被称为'达克效应'。","source":"_posts/如何清楚的认识到自己的无知.md","raw":"---\ntitle: 如何清楚的认识到自己的无知\ncatalog: true\nsubtitle: 也许我们都忘记了‘井底之蛙的故事’。一个大家都记得，但是没有再思考过的故事。\nheader-img: 'http://pvpmnqrh8.bkt.clouddn.com/rain-4376988_1280.jpg'\ntags:\n  - 生活\ncategroies:\n  - 随笔\nabbrlink: 7460b142\ndate: 2019-08-08 15:10:30\n---\n## 井底之蛙\n\n>\"井蛙不可以语于海者，拘于虚也。\" --《庄子·秋水》\n\n![image](http://pvpmnqrh8.bkt.clouddn.com/u=3393515458,1954360820&fm=26&gp=0.jpg)\n\n一只青蛙它拥有一口井。我们作为一个人，又拥有什么呢。我们拥有比青蛙更聪明的大脑。然而大部分情况下，我们跟青蛙一样坐井观天。\n\n井底之蛙的故事大家都清楚，同时我相信没有一个人会把这个故事忘了。故事的道理大家也都清楚。但是也许大部分人都没有从这个故事中获得应该得到的。原因或许是：鸟在井边，蛙在井里，人在画外罢了。我们将自己摆在了一个高于两者的位置上。\n我们认为我们懂得比那个无知的青蛙多，我们认为我们比鸟看的更高。也许我们应该保持自己的对无知的敬畏，才能使自己不成为那只青蛙吧。\n\n![image](http://pvpmnqrh8.bkt.clouddn.com/3421338-6bc1c9302d4e74bb.jpg)\n\n> 整个世界的问题在于，愚者和狂徒对自己总是如此确信，而智者则满是疑虑。——伯特兰·罗素\n\n\n'高估自己'、'过度自信'，这种现象在心理学被称为'达克效应'。","slug":"如何清楚的认识到自己的无知","published":1,"updated":"2024-03-03T07:00:28.964Z","comments":1,"layout":"post","photos":[],"_id":"cltbcc4gf00044o9v57uf1i0u","content":"<h2 id=\"井底之蛙\"><a href=\"#井底之蛙\" class=\"headerlink\" title=\"井底之蛙\"></a>井底之蛙</h2><blockquote>\n<p>“井蛙不可以语于海者，拘于虚也。” –《庄子·秋水》</p>\n</blockquote>\n<p><img src=\"http://pvpmnqrh8.bkt.clouddn.com/u=3393515458,1954360820&fm=26&gp=0.jpg\" alt=\"image\"></p>\n<p>一只青蛙它拥有一口井。我们作为一个人，又拥有什么呢。我们拥有比青蛙更聪明的大脑。然而大部分情况下，我们跟青蛙一样坐井观天。</p>\n<p>井底之蛙的故事大家都清楚，同时我相信没有一个人会把这个故事忘了。故事的道理大家也都清楚。但是也许大部分人都没有从这个故事中获得应该得到的。原因或许是：鸟在井边，蛙在井里，人在画外罢了。我们将自己摆在了一个高于两者的位置上。<br>我们认为我们懂得比那个无知的青蛙多，我们认为我们比鸟看的更高。也许我们应该保持自己的对无知的敬畏，才能使自己不成为那只青蛙吧。</p>\n<p><img src=\"http://pvpmnqrh8.bkt.clouddn.com/3421338-6bc1c9302d4e74bb.jpg\" alt=\"image\"></p>\n<blockquote>\n<p>整个世界的问题在于，愚者和狂徒对自己总是如此确信，而智者则满是疑虑。——伯特兰·罗素</p>\n</blockquote>\n<p>‘高估自己’、’过度自信’，这种现象在心理学被称为’达克效应’。</p>\n","excerpt":"","more":"<h2 id=\"井底之蛙\"><a href=\"#井底之蛙\" class=\"headerlink\" title=\"井底之蛙\"></a>井底之蛙</h2><blockquote>\n<p>“井蛙不可以语于海者，拘于虚也。” –《庄子·秋水》</p>\n</blockquote>\n<p><img src=\"http://pvpmnqrh8.bkt.clouddn.com/u=3393515458,1954360820&fm=26&gp=0.jpg\" alt=\"image\"></p>\n<p>一只青蛙它拥有一口井。我们作为一个人，又拥有什么呢。我们拥有比青蛙更聪明的大脑。然而大部分情况下，我们跟青蛙一样坐井观天。</p>\n<p>井底之蛙的故事大家都清楚，同时我相信没有一个人会把这个故事忘了。故事的道理大家也都清楚。但是也许大部分人都没有从这个故事中获得应该得到的。原因或许是：鸟在井边，蛙在井里，人在画外罢了。我们将自己摆在了一个高于两者的位置上。<br>我们认为我们懂得比那个无知的青蛙多，我们认为我们比鸟看的更高。也许我们应该保持自己的对无知的敬畏，才能使自己不成为那只青蛙吧。</p>\n<p><img src=\"http://pvpmnqrh8.bkt.clouddn.com/3421338-6bc1c9302d4e74bb.jpg\" alt=\"image\"></p>\n<blockquote>\n<p>整个世界的问题在于，愚者和狂徒对自己总是如此确信，而智者则满是疑虑。——伯特兰·罗素</p>\n</blockquote>\n<p>‘高估自己’、’过度自信’，这种现象在心理学被称为’达克效应’。</p>\n"},{"title":"跨域请求设置说明","catalog":true,"subtitle":"http 跨域请求，请求报文信息说明","header-img":"http://pvpmnqrh8.bkt.clouddn.com/tag-bg.png","abbrlink":"ffac7d67","date":"2019-08-04T15:07:45.000Z","_content":"\nCORS把HTTP请求分成两类，不同类别按不同的策略进行跨域资源共享协商。\n\n## 简单跨域请求。\n当HTTP请求出现以下两种情况时，浏览器认为是简单跨域请求：\n\n1). 请求方法是GET、HEAD或者POST，并且当请求方法是POST时，Content-Type必须是application/x-www-form-urlencoded, multipart/form-data或着text/plain中的一个值。\n2). 请求中没有自定义HTTP头部。\n\n对于简单跨域请求，浏览器要做的就是在HTTP请求中添加Origin Header，将[JavaScript](http://lib.csdn.net/base/18 \"JavaScript知识库\")脚本所在域填充进去，向其他域的服务器请求资源。服务器端收到一个简单跨域请求后，根据资源权限配置，在响应头中添加Access-Control-Allow-Origin Header。浏览器收到响应后，查看Access-Control-Allow-Origin Header，如果当前域已经得到授权，则将结果返回给[JavaScript](http://lib.csdn.net/base/javascript \"JavaScript知识库\")。否则浏览器忽略此次响应。\n\n## 带预检(Preflighted)的跨域请求。\n当HTTP请求出现以下两种情况时，浏览器认为是带预检(Preflighted)的跨域请求：\n\n1). 除GET、HEAD和POST(only with application/x-www-form-urlencoded, multipart/form-data, text/plain Content-Type)以外的其他HTTP方法。\n2). 请求中出现自定义HTTP头部。\n\n带预检(Preflighted)的跨域请求需要浏览器在发送真实HTTP请求之前先发送一个OPTIONS的预检请求，检测服务器端是否支持真实请求进行跨域资源访问，真实请求的信息在OPTIONS请求中通过Access-Control-Request-Method Header和Access-Control-Request-Headers Header描述，此外与简单跨域请求一样，浏览器也会添加Origin Header。服务器端接到预检请求后，根据资源权限配置，在响应头中放入Access-Control-Allow-Origin Header、Access-Control-Allow-Methods和Access-Control-Allow-Headers Header，分别表示允许跨域资源请求的域、请求方法和请求头。此外，服务器端还可以加入Access-Control-Max-Age Header，允许浏览器在指定时间内，无需再发送预检请求进行协商，直接用本次协商结果即可。浏览器根据OPTIONS请求返回的结果来决定是否继续发送真实的请求进行跨域资源访问。这个过程对真实请求的调用者来说是透明的。\n\nXMLHttpRequest支持通过withCredentials属性实现在跨域请求携带身份信息(Credential，例如Cookie或者HTTP认证信息)。浏览器将携带Cookie Header的请求发送到服务器端后，如果服务器没有响应Access-Control-Allow-Credentials Header，那么浏览器会忽略掉这次响应。\n\n这里讨论的HTTP请求是指由Ajax XMLHttpRequest对象发起的，所有的CORS HTTP请求头都可由浏览器填充，无需在XMLHttpRequest对象中设置。以下是CORS协议规定的HTTP头，用来进行浏览器发起跨域资源请求时进行协商：\n\n1. Origin。HTTP请求头，任何涉及CORS的请求都必需携带。\n2. Access-Control-Request-Method。HTTP请求头，在带预检(Preflighted)的跨域请求中用来表示真实请求的方法。\n3. Access-Control-Request-Headers。HTTP请求头，在带预检(Preflighted)的跨域请求中用来表示真实请求的自定义Header列表。\n4. Access-Control-Allow-Origin。HTTP响应头，指定服务器端允许进行跨域资源访问的来源域。可以用通配符*表示允许任何域的JavaScript访问资源，但是在响应一个携带身份信息(Credential)的HTTP请求时，Access-Control-Allow-Origin必需指定具体的域，不能用通配符。\n5. Access-Control-Allow-Methods。HTTP响应头，指定服务器允许进行跨域资源访问的请求方法列表，一般用在响应预检请求上。\n6. Access-Control-Allow-Headers。HTTP响应头，指定服务器允许进行跨域资源访问的请求头列表，一般用在响应预检请求上。\n7. Access-Control-Max-Age。HTTP响应头，用在响应预检请求上，表示本次预检响应的有效时间。在此时间内，浏览器都可以根据此次协商结果决定是否有必要直接发送真实请求，而无需再次发送预检请求。\n8. Access-Control-Allow-Credentials。HTTP响应头，凡是浏览器请求中携带了身份信息，而响应头中没有返回Access-Control-Allow-Credentials: true的，浏览器都会忽略此次响应。\n","source":"_posts/跨域请求设置说明.md","raw":"---\ntitle: 跨域请求设置说明\ncatalog: true\nsubtitle: http 跨域请求，请求报文信息说明\nheader-img: 'http://pvpmnqrh8.bkt.clouddn.com/tag-bg.png'\ntags:\n  - http\n  - cors\ncategories:\n  - web\nabbrlink: ffac7d67\ndate: 2019-08-04 23:07:45\n---\n\nCORS把HTTP请求分成两类，不同类别按不同的策略进行跨域资源共享协商。\n\n## 简单跨域请求。\n当HTTP请求出现以下两种情况时，浏览器认为是简单跨域请求：\n\n1). 请求方法是GET、HEAD或者POST，并且当请求方法是POST时，Content-Type必须是application/x-www-form-urlencoded, multipart/form-data或着text/plain中的一个值。\n2). 请求中没有自定义HTTP头部。\n\n对于简单跨域请求，浏览器要做的就是在HTTP请求中添加Origin Header，将[JavaScript](http://lib.csdn.net/base/18 \"JavaScript知识库\")脚本所在域填充进去，向其他域的服务器请求资源。服务器端收到一个简单跨域请求后，根据资源权限配置，在响应头中添加Access-Control-Allow-Origin Header。浏览器收到响应后，查看Access-Control-Allow-Origin Header，如果当前域已经得到授权，则将结果返回给[JavaScript](http://lib.csdn.net/base/javascript \"JavaScript知识库\")。否则浏览器忽略此次响应。\n\n## 带预检(Preflighted)的跨域请求。\n当HTTP请求出现以下两种情况时，浏览器认为是带预检(Preflighted)的跨域请求：\n\n1). 除GET、HEAD和POST(only with application/x-www-form-urlencoded, multipart/form-data, text/plain Content-Type)以外的其他HTTP方法。\n2). 请求中出现自定义HTTP头部。\n\n带预检(Preflighted)的跨域请求需要浏览器在发送真实HTTP请求之前先发送一个OPTIONS的预检请求，检测服务器端是否支持真实请求进行跨域资源访问，真实请求的信息在OPTIONS请求中通过Access-Control-Request-Method Header和Access-Control-Request-Headers Header描述，此外与简单跨域请求一样，浏览器也会添加Origin Header。服务器端接到预检请求后，根据资源权限配置，在响应头中放入Access-Control-Allow-Origin Header、Access-Control-Allow-Methods和Access-Control-Allow-Headers Header，分别表示允许跨域资源请求的域、请求方法和请求头。此外，服务器端还可以加入Access-Control-Max-Age Header，允许浏览器在指定时间内，无需再发送预检请求进行协商，直接用本次协商结果即可。浏览器根据OPTIONS请求返回的结果来决定是否继续发送真实的请求进行跨域资源访问。这个过程对真实请求的调用者来说是透明的。\n\nXMLHttpRequest支持通过withCredentials属性实现在跨域请求携带身份信息(Credential，例如Cookie或者HTTP认证信息)。浏览器将携带Cookie Header的请求发送到服务器端后，如果服务器没有响应Access-Control-Allow-Credentials Header，那么浏览器会忽略掉这次响应。\n\n这里讨论的HTTP请求是指由Ajax XMLHttpRequest对象发起的，所有的CORS HTTP请求头都可由浏览器填充，无需在XMLHttpRequest对象中设置。以下是CORS协议规定的HTTP头，用来进行浏览器发起跨域资源请求时进行协商：\n\n1. Origin。HTTP请求头，任何涉及CORS的请求都必需携带。\n2. Access-Control-Request-Method。HTTP请求头，在带预检(Preflighted)的跨域请求中用来表示真实请求的方法。\n3. Access-Control-Request-Headers。HTTP请求头，在带预检(Preflighted)的跨域请求中用来表示真实请求的自定义Header列表。\n4. Access-Control-Allow-Origin。HTTP响应头，指定服务器端允许进行跨域资源访问的来源域。可以用通配符*表示允许任何域的JavaScript访问资源，但是在响应一个携带身份信息(Credential)的HTTP请求时，Access-Control-Allow-Origin必需指定具体的域，不能用通配符。\n5. Access-Control-Allow-Methods。HTTP响应头，指定服务器允许进行跨域资源访问的请求方法列表，一般用在响应预检请求上。\n6. Access-Control-Allow-Headers。HTTP响应头，指定服务器允许进行跨域资源访问的请求头列表，一般用在响应预检请求上。\n7. Access-Control-Max-Age。HTTP响应头，用在响应预检请求上，表示本次预检响应的有效时间。在此时间内，浏览器都可以根据此次协商结果决定是否有必要直接发送真实请求，而无需再次发送预检请求。\n8. Access-Control-Allow-Credentials。HTTP响应头，凡是浏览器请求中携带了身份信息，而响应头中没有返回Access-Control-Allow-Credentials: true的，浏览器都会忽略此次响应。\n","slug":"跨域请求设置说明","published":1,"updated":"2024-03-03T07:00:28.964Z","comments":1,"layout":"post","photos":[],"_id":"cltbcc4gu000f4o9v31j11sm9","content":"<p>CORS把HTTP请求分成两类，不同类别按不同的策略进行跨域资源共享协商。</p>\n<h2 id=\"简单跨域请求。\"><a href=\"#简单跨域请求。\" class=\"headerlink\" title=\"简单跨域请求。\"></a>简单跨域请求。</h2><p>当HTTP请求出现以下两种情况时，浏览器认为是简单跨域请求：</p>\n<p>1). 请求方法是GET、HEAD或者POST，并且当请求方法是POST时，Content-Type必须是application&#x2F;x-www-form-urlencoded, multipart&#x2F;form-data或着text&#x2F;plain中的一个值。<br>2). 请求中没有自定义HTTP头部。</p>\n<p>对于简单跨域请求，浏览器要做的就是在HTTP请求中添加Origin Header，将<a href=\"http://lib.csdn.net/base/18\" title=\"JavaScript知识库\">JavaScript</a>脚本所在域填充进去，向其他域的服务器请求资源。服务器端收到一个简单跨域请求后，根据资源权限配置，在响应头中添加Access-Control-Allow-Origin Header。浏览器收到响应后，查看Access-Control-Allow-Origin Header，如果当前域已经得到授权，则将结果返回给<a href=\"http://lib.csdn.net/base/javascript\" title=\"JavaScript知识库\">JavaScript</a>。否则浏览器忽略此次响应。</p>\n<h2 id=\"带预检-Preflighted-的跨域请求。\"><a href=\"#带预检-Preflighted-的跨域请求。\" class=\"headerlink\" title=\"带预检(Preflighted)的跨域请求。\"></a>带预检(Preflighted)的跨域请求。</h2><p>当HTTP请求出现以下两种情况时，浏览器认为是带预检(Preflighted)的跨域请求：</p>\n<p>1). 除GET、HEAD和POST(only with application&#x2F;x-www-form-urlencoded, multipart&#x2F;form-data, text&#x2F;plain Content-Type)以外的其他HTTP方法。<br>2). 请求中出现自定义HTTP头部。</p>\n<p>带预检(Preflighted)的跨域请求需要浏览器在发送真实HTTP请求之前先发送一个OPTIONS的预检请求，检测服务器端是否支持真实请求进行跨域资源访问，真实请求的信息在OPTIONS请求中通过Access-Control-Request-Method Header和Access-Control-Request-Headers Header描述，此外与简单跨域请求一样，浏览器也会添加Origin Header。服务器端接到预检请求后，根据资源权限配置，在响应头中放入Access-Control-Allow-Origin Header、Access-Control-Allow-Methods和Access-Control-Allow-Headers Header，分别表示允许跨域资源请求的域、请求方法和请求头。此外，服务器端还可以加入Access-Control-Max-Age Header，允许浏览器在指定时间内，无需再发送预检请求进行协商，直接用本次协商结果即可。浏览器根据OPTIONS请求返回的结果来决定是否继续发送真实的请求进行跨域资源访问。这个过程对真实请求的调用者来说是透明的。</p>\n<p>XMLHttpRequest支持通过withCredentials属性实现在跨域请求携带身份信息(Credential，例如Cookie或者HTTP认证信息)。浏览器将携带Cookie Header的请求发送到服务器端后，如果服务器没有响应Access-Control-Allow-Credentials Header，那么浏览器会忽略掉这次响应。</p>\n<p>这里讨论的HTTP请求是指由Ajax XMLHttpRequest对象发起的，所有的CORS HTTP请求头都可由浏览器填充，无需在XMLHttpRequest对象中设置。以下是CORS协议规定的HTTP头，用来进行浏览器发起跨域资源请求时进行协商：</p>\n<ol>\n<li>Origin。HTTP请求头，任何涉及CORS的请求都必需携带。</li>\n<li>Access-Control-Request-Method。HTTP请求头，在带预检(Preflighted)的跨域请求中用来表示真实请求的方法。</li>\n<li>Access-Control-Request-Headers。HTTP请求头，在带预检(Preflighted)的跨域请求中用来表示真实请求的自定义Header列表。</li>\n<li>Access-Control-Allow-Origin。HTTP响应头，指定服务器端允许进行跨域资源访问的来源域。可以用通配符*表示允许任何域的JavaScript访问资源，但是在响应一个携带身份信息(Credential)的HTTP请求时，Access-Control-Allow-Origin必需指定具体的域，不能用通配符。</li>\n<li>Access-Control-Allow-Methods。HTTP响应头，指定服务器允许进行跨域资源访问的请求方法列表，一般用在响应预检请求上。</li>\n<li>Access-Control-Allow-Headers。HTTP响应头，指定服务器允许进行跨域资源访问的请求头列表，一般用在响应预检请求上。</li>\n<li>Access-Control-Max-Age。HTTP响应头，用在响应预检请求上，表示本次预检响应的有效时间。在此时间内，浏览器都可以根据此次协商结果决定是否有必要直接发送真实请求，而无需再次发送预检请求。</li>\n<li>Access-Control-Allow-Credentials。HTTP响应头，凡是浏览器请求中携带了身份信息，而响应头中没有返回Access-Control-Allow-Credentials: true的，浏览器都会忽略此次响应。</li>\n</ol>\n","excerpt":"","more":"<p>CORS把HTTP请求分成两类，不同类别按不同的策略进行跨域资源共享协商。</p>\n<h2 id=\"简单跨域请求。\"><a href=\"#简单跨域请求。\" class=\"headerlink\" title=\"简单跨域请求。\"></a>简单跨域请求。</h2><p>当HTTP请求出现以下两种情况时，浏览器认为是简单跨域请求：</p>\n<p>1). 请求方法是GET、HEAD或者POST，并且当请求方法是POST时，Content-Type必须是application&#x2F;x-www-form-urlencoded, multipart&#x2F;form-data或着text&#x2F;plain中的一个值。<br>2). 请求中没有自定义HTTP头部。</p>\n<p>对于简单跨域请求，浏览器要做的就是在HTTP请求中添加Origin Header，将<a href=\"http://lib.csdn.net/base/18\" title=\"JavaScript知识库\">JavaScript</a>脚本所在域填充进去，向其他域的服务器请求资源。服务器端收到一个简单跨域请求后，根据资源权限配置，在响应头中添加Access-Control-Allow-Origin Header。浏览器收到响应后，查看Access-Control-Allow-Origin Header，如果当前域已经得到授权，则将结果返回给<a href=\"http://lib.csdn.net/base/javascript\" title=\"JavaScript知识库\">JavaScript</a>。否则浏览器忽略此次响应。</p>\n<h2 id=\"带预检-Preflighted-的跨域请求。\"><a href=\"#带预检-Preflighted-的跨域请求。\" class=\"headerlink\" title=\"带预检(Preflighted)的跨域请求。\"></a>带预检(Preflighted)的跨域请求。</h2><p>当HTTP请求出现以下两种情况时，浏览器认为是带预检(Preflighted)的跨域请求：</p>\n<p>1). 除GET、HEAD和POST(only with application&#x2F;x-www-form-urlencoded, multipart&#x2F;form-data, text&#x2F;plain Content-Type)以外的其他HTTP方法。<br>2). 请求中出现自定义HTTP头部。</p>\n<p>带预检(Preflighted)的跨域请求需要浏览器在发送真实HTTP请求之前先发送一个OPTIONS的预检请求，检测服务器端是否支持真实请求进行跨域资源访问，真实请求的信息在OPTIONS请求中通过Access-Control-Request-Method Header和Access-Control-Request-Headers Header描述，此外与简单跨域请求一样，浏览器也会添加Origin Header。服务器端接到预检请求后，根据资源权限配置，在响应头中放入Access-Control-Allow-Origin Header、Access-Control-Allow-Methods和Access-Control-Allow-Headers Header，分别表示允许跨域资源请求的域、请求方法和请求头。此外，服务器端还可以加入Access-Control-Max-Age Header，允许浏览器在指定时间内，无需再发送预检请求进行协商，直接用本次协商结果即可。浏览器根据OPTIONS请求返回的结果来决定是否继续发送真实的请求进行跨域资源访问。这个过程对真实请求的调用者来说是透明的。</p>\n<p>XMLHttpRequest支持通过withCredentials属性实现在跨域请求携带身份信息(Credential，例如Cookie或者HTTP认证信息)。浏览器将携带Cookie Header的请求发送到服务器端后，如果服务器没有响应Access-Control-Allow-Credentials Header，那么浏览器会忽略掉这次响应。</p>\n<p>这里讨论的HTTP请求是指由Ajax XMLHttpRequest对象发起的，所有的CORS HTTP请求头都可由浏览器填充，无需在XMLHttpRequest对象中设置。以下是CORS协议规定的HTTP头，用来进行浏览器发起跨域资源请求时进行协商：</p>\n<ol>\n<li>Origin。HTTP请求头，任何涉及CORS的请求都必需携带。</li>\n<li>Access-Control-Request-Method。HTTP请求头，在带预检(Preflighted)的跨域请求中用来表示真实请求的方法。</li>\n<li>Access-Control-Request-Headers。HTTP请求头，在带预检(Preflighted)的跨域请求中用来表示真实请求的自定义Header列表。</li>\n<li>Access-Control-Allow-Origin。HTTP响应头，指定服务器端允许进行跨域资源访问的来源域。可以用通配符*表示允许任何域的JavaScript访问资源，但是在响应一个携带身份信息(Credential)的HTTP请求时，Access-Control-Allow-Origin必需指定具体的域，不能用通配符。</li>\n<li>Access-Control-Allow-Methods。HTTP响应头，指定服务器允许进行跨域资源访问的请求方法列表，一般用在响应预检请求上。</li>\n<li>Access-Control-Allow-Headers。HTTP响应头，指定服务器允许进行跨域资源访问的请求头列表，一般用在响应预检请求上。</li>\n<li>Access-Control-Max-Age。HTTP响应头，用在响应预检请求上，表示本次预检响应的有效时间。在此时间内，浏览器都可以根据此次协商结果决定是否有必要直接发送真实请求，而无需再次发送预检请求。</li>\n<li>Access-Control-Allow-Credentials。HTTP响应头，凡是浏览器请求中携带了身份信息，而响应头中没有返回Access-Control-Allow-Credentials: true的，浏览器都会忽略此次响应。</li>\n</ol>\n"}],"PostAsset":[],"PostCategory":[{"post_id":"cltbcc4g200004o9v07an6y4b","category_id":"cltbcc4gc00024o9vd3tyewbh","_id":"cltbcc4gj00074o9v7ixdbbzb"},{"post_id":"cltbcc4g900014o9vgopeau0c","category_id":"cltbcc4gc00024o9vd3tyewbh","_id":"cltbcc4gj000a4o9vgie1cmqw"},{"post_id":"cltbcc4gu000f4o9v31j11sm9","category_id":"cltbcc4gc00024o9vd3tyewbh","_id":"cltbcc4gx000h4o9v20h72hdd"}],"PostTag":[{"post_id":"cltbcc4g200004o9v07an6y4b","tag_id":"cltbcc4gf00034o9v9llmb7sr","_id":"cltbcc4gj00094o9v0rbx40xu"},{"post_id":"cltbcc4g200004o9v07an6y4b","tag_id":"cltbcc4gi00064o9v6ws3dlzq","_id":"cltbcc4gj000b4o9v3zov2240"},{"post_id":"cltbcc4g900014o9vgopeau0c","tag_id":"cltbcc4gj00084o9vdc7m2mw2","_id":"cltbcc4gk000d4o9v9wr68kys"},{"post_id":"cltbcc4gf00044o9v57uf1i0u","tag_id":"cltbcc4gj000c4o9v73xf5upq","_id":"cltbcc4gk000e4o9v978wd6e0"},{"post_id":"cltbcc4gu000f4o9v31j11sm9","tag_id":"cltbcc4gw000g4o9vg2la3115","_id":"cltbcc4gx000j4o9v759k1q51"},{"post_id":"cltbcc4gu000f4o9v31j11sm9","tag_id":"cltbcc4gx000i4o9v3c94gx9o","_id":"cltbcc4gx000k4o9v66izaaby"}],"Tag":[{"name":"spring security","_id":"cltbcc4gf00034o9v9llmb7sr"},{"name":"spring oauth2","_id":"cltbcc4gi00064o9v6ws3dlzq"},{"name":"redis","_id":"cltbcc4gj00084o9vdc7m2mw2"},{"name":"生活","_id":"cltbcc4gj000c4o9v73xf5upq"},{"name":"http","_id":"cltbcc4gw000g4o9vg2la3115"},{"name":"cors","_id":"cltbcc4gx000i4o9v3c94gx9o"}]}}